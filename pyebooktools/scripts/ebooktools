#!/usr/bin/env python
"""This script is a Python port of ebook-tools by na-- (See
https://github.com/na--/ebook-tools).
"""
# NOTE: since ebooktools is a script (no py extension), it can't be imported
import argparse
import platform
import os
import sys

import ipdb

import pyebooktools
from pyebooktools import lib, split_into_folders
from pyebooktools.utils.genutils import (dict_to_bunch, get_config_dict,
                                         init_log, namespace_to_dict, run_cmd,
                                         setup_log)

logger = init_log(__name__, __file__)

# ==============
# Default values
# ==============
_LOG_CFG = "log"
_MAIN_CFG = "config"


# NOTE: https://stackoverflow.com/a/27163648 [launch PyCharm from terminal]
def edit_file(filepath, app=None, create_if_not=False):
    """Edit a file.

    TODO: remove config

    The user chooses the config file (`cfg_filepath`) to edit: the
    `logging config file`_, `main config file`_ or a particular model
    configuration file (e.g. LogisticRegression)

    The configuration file can be opened by a user-specified application (`app`)
    or a default program associated with this type of file (when `app` is
    :obj:`None`).

    Parameters
    ----------
    filepath : str
        The configuration file to edit. The `logging config file`_,
        `main config file`_ or a particular model configuration file (e.g.
        LogisticRegression).
    app : str, optional
        Name of the application to use for opening the config file, e.g.
        `TextEdit` (the default value is :obj:`None` which implies that the
        default application will be used to open the config file).

    Returns
    -------
    retcode : int
        If there is a `subprocess
        <https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError>`_
        -related error, the return code is non-zero. Otherwise, it is 0 if the
        file can be successfully opened with an external program.

    """
    # Check if file exists
    file_exists = os.path.exists(filepath)
    if not file_exists and not create_if_not:
        logger.error(f"The file doesn't exists: {filepath}")
        return 1
    # Command to open the config file with the default application in the
    # OS or the user-specified app, e.g. `open filepath` in macOS opens the
    # file with the default app (e.g. atom)
    default_cmd_dict = {'Darwin': 'open {filepath}',
                        'Linux': 'xdg-open {filepath}',
                        'Windows': 'cmd /c start "" "{filepath}"'}
    # NOTE: check https://bit.ly/31htaOT (pymotw) for output from
    # platform.system on three OSes
    default_cmd = default_cmd_dict.get(platform.system())
    # NOTES:
    # - `app is None` implies that the default app will be used
    # - Otherwise, the user-specified app will be used
    cmd = default_cmd if app is None else app + " " + filepath
    retcode = 1
    result = None
    try:
        # IMPORTANT: if the user provided the name of an app, it will be used as
        # a command along with the file path, e.g. ``$ atom {filepath}``.
        # However, this case might not work if the user provided an app name
        # that doesn't refer to an executable, e.g. ``$ TextEdit {filepath}``
        # won't work. The failed case is further processed in the except block.
        result = run_cmd(cmd.format(filepath=filepath))
        retcode = result.returncode
    except FileNotFoundError:
        # This error happens if the name of the app can't be called as an
        # executable in the terminal
        # e.g. `TextEdit` can't be run in the terminal but `atom` can since the
        # latter refers to an executable.
        # To open `TextEdit` from the terminal, the command ``open -a TextEdit``
        # must be used on macOS.
        # TODO: IMPORTANT add the open commands for the other OSes
        specific_cmd_dict = {'Darwin': 'open -a {app}'.format(app=app)}
        # Get the command to open the file with the user-specified app
        cmd = specific_cmd_dict.get(platform.system(), app) + " " + filepath
        # TODO: explain DEVNULL, suppress stderr since we will display the error
        # TODO: IMPORTANT you might get a FileNotFoundError again?
        result = run_cmd(cmd)  # stderr=subprocess.DEVNULL)
        retcode = result.returncode
    if retcode == 0:
        if create_if_not:
            logger.warning(f"The file doesn't exists but will be created: "
                           f"{filepath}'")
        logger.info("Opening the file {}...".format(
            os.path.basename(filepath)))
        logger.debug(f"Filepath: {filepath}")
    else:
        if result:
            err = result.stderr.decode().strip()
            logger.error(err)
    return retcode


def get_main_config(args):
    # -------------------------------------
    # Get config filepath and setup logging
    # -------------------------------------
    # Get config dict
    main_cfg_dict = get_config_dict('main')
    main_cfg = dict_to_bunch(main_cfg_dict)
    setup_log(main_cfg.quiet, main_cfg.verbose,
              logging_level=args.logging_level,
              logging_formatter=args.logging_formatter)
    return main_cfg


def parse_edit_args(args):
    pass


def parse_split_into_folders_args(args):
    split_into_folders.split(**namespace_to_dict(args))


# Ref.: https://stackoverflow.com/a/14117511/14664104
def check_positive(value):
    try:
        # TODO: 2.0 rejected
        ivalue = int(value)
        if ivalue <= 0:
            raise argparse.ArgumentTypeError(
                f"{value} is an invalid positive int value")
    except ValueError:
        raise argparse.ArgumentTypeError(
            f"{value} is an invalid positive int value")
    else:
        return ivalue


def setup_argparser():
    """Setup the argument parser for the command-line script.

    Returns
    -------
    parser : argparse.ArgumentParser
        Argument parser.

    """
    # Setup the parser
    parser = argparse.ArgumentParser(
        description='''\
This program is a Python port of ebook-tools by na-- (See
https://github.com/na--/ebook-tools).

This program is a collection of Python scripts for automated and
semi-automated organization and management of large ebook collections.

See subcommands below for a list of the scripts that can be run.
''',
        # formatter_class=argparse.RawDescriptionHelpFormatter)
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    # ===============
    # General options
    # ===============
    # TODO: package name too? instead of program name
    parser.add_argument('--version', action='version',
                        version='%(prog)s v{}'.format(pyebooktools.__version__))
    parser.add_argument("-q", "--quiet", action="store_true",
                        help="Enable quiet mode, i.e. nothing will be printed.")
    parser.add_argument("-v", "--verbose", action="store_true",
                        help="Print various debugging information, e.g. print "
                             "traceback when there is an exception.")
    # TODO: add help for the following options
    parser.add_argument(
        '--loglvl', dest='logging_level', default='INFO',
        choices=['debug', 'info', 'warning', 'error'],
        help='')
    parser.add_argument(
        '--logfmt', dest='logging_formatter', default='only_msg',
        choices=['console', 'simple', 'only_msg'],
        help='')
    # =============================================
    # Options related to the input and output files
    # =============================================
    parser_input_output_group = parser.add_argument_group(
        title='Options related to the input and output files')
    parser_input_output_group.add_argument(
        '--oft', '--output-filename-template', dest='output_filename_template',
        default=lib.OUTPUT_FILENAME_TEMPLATE,
        metavar='TEMPLATE',
        help='This specifies how the filenames of the organized files will '
             'look. It is a bash string that is evaluated so it can be very '
             'flexible (and also potentially unsafe).')
    parser_input_output_group.add_argument(
        '--ome', '--output-metadata-extension', dest='output_metadata_extension',
        default=lib.OUTPUT_METADATA_EXTENSION, metavar='EXTENSION',
        help='''If KEEP_METADATA is enabled, this is the extension of the
        additional metadata file that is saved next to each newly renamed file.''')
    # ===========
    # Subcommands
    # ===========
    subparsers = parser.add_subparsers(
        title='subcommands', description=None, dest='subparser_name',
        help=None)
    # ==========
    # Edit files
    # ==========
    # create the parser for the "edit" command
    parser_edit = subparsers.add_parser(
        'edit', formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        help='''Edit a configuration file.''')
    parser_edit.add_argument(
        'filename', choices=[_MAIN_CFG, _LOG_CFG],
        help='''Name of a file to edit which can either be the main
            configuration file ('config') or the logging configuration file
            ('log').''')
    group_edit = parser_edit.add_mutually_exclusive_group()
    group_edit.add_argument(
        '-a', '--app', metavar='NAME', nargs='?', default='default_editor',
        help='''Name of the application to use for editing the file. If no name
        is given, then the default application for opening this type of file
        will be used.''')
    group_edit.add_argument(
        "-r", "--reset", action="store_true",
        help='''Reset a configuration file ('config' or 'log') with factory
        default values.''')
    parser_edit.set_defaults(func=parse_edit_args)
    # ==================
    # split-into-folders
    # ==================
    # create the parser for the "split-into-folders" command
    parser_split_into_folders = subparsers.add_parser(
        'split', formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        help='''Split the supplied ebook files (and the accompanying metadata
        files if present) into folders with consecutive names that each contain
        the specified number of files.''')
    parser_split_into_folders.add_argument(
        'folder_with_books', metavar='FOLDER_WITH_BOOKS',
        help='''Folder with books which will be recursively scanned for files.
        The found files (and the accompanying metadata files if present) will 
        be split into folders with consecutive names that each contain the 
        specified number of files.''')
    parser_split_into_folders.add_argument(
        '-o', '--output-folder', dest='output_folder', metavar='PATH',
        default=split_into_folders.OUTPUT_FOLDER,
        help='''The output folder in which all the new consecutively named
        folders will be created. The default is the current working
        directory.''')
    parser_split_into_folders.add_argument(
        '-s', '--start-number', dest='start_number', type=int,
        default=split_into_folders.START_NUMBER,
        help='''The number of the first folder.''')
    parser_split_into_folders.add_argument(
        '-f', '--folder-pattern', dest='folder_pattern', metavar='PATTERN',
        default=split_into_folders.FOLDER_PATTERN,
        help='''The print format string that specifies the pattern with which
        new folders will be created. By default it creates folders like
        00000000, 00001000, 00002000, .....''')
    parser_split_into_folders.add_argument(
        '--fpf', '--files-per-folder', dest='files_per_folder', type=check_positive,
        default=split_into_folders.FILES_PER_FOLDER,
        help='''How many files should be moved to each folder.''')
    parser_split_into_folders.set_defaults(func=parse_split_into_folders_args)
    return parser


def main():
    try:
        parser = setup_argparser()
        args = parser.parse_args()
        test = args
        # ipdb.set_trace()
        # main_cfg, cwd_ready = get_main_config(args)
        # return args.func(args, main_cfg)
        return args.func(args)

    except AssertionError as e:
        # TODO (IMPORTANT): use same logic as in Darth-Vader-RPi
        # TODO: add KeyboardInterruptError
        logger.error(e)
        return 1


if __name__ == '__main__':
    retcode = main()
    msg = "Program exited with {}".format(retcode)
    if retcode == 1:
        logger.error(msg)
    else:
        logger.info(msg)
